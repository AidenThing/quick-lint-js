// Code generated by tools/generate-lex-tables.cpp. DO NOT EDIT.

// Copyright (C) 2020  Matthew "strager" Glazar
// See end of file for extended copyright information.

#ifndef QUICK_LINT_JS_FE_LEX_TABLES_GENERATED_H
#define QUICK_LINT_JS_FE_LEX_TABLES_GENERATED_H

#include <cstdint>
#include <quick-lint-js/assert.h>
#include <quick-lint-js/fe/lex.h>
#include <quick-lint-js/fe/token.h>
#include <quick-lint-js/port/char8.h>
#include <quick-lint-js/port/warning.h>

namespace quick_lint_js {
struct lex_tables {
  // See NOTE[lex-table-class].
  static constexpr std::uint8_t character_class_table[256] = {
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  //
      8, 0, 8, 8, 8, 1, 2, 8, 8, 8, 8, 3, 8, 8, 8, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 5, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  //
      8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  //
  };
  static constexpr int character_class_count = 8;

  enum state : std::uint8_t {
    // Initial states:
    bang,
    percent,
    ampersand,
    plus,
    equal,
    greater,
    circumflex,
    pipe,

    // Possibly-incomplete states:
    bang_equal,
    ampersand_ampersand,
    equal_equal,
    greater_greater,
    pipe_pipe,
    greater_greater_greater,

    // Complete/terminal states:
    done_percent_equal,
    done_ampersand_equal,
    done_plus_plus,
    done_plus_equal,
    done_equal_greater,
    done_greater_equal,
    done_circumflex_equal,
    done_pipe_equal,
    done_bang_equal_equal,
    done_ampersand_ampersand_equal,
    done_equal_equal_equal,
    done_greater_greater_equal,
    done_pipe_pipe_equal,
    done_greater_greater_greater_equal,

    // An unexpected character was detected. The lexer should retract the most
    // recent byte.
    retract,
  };
  static constexpr int input_state_count = 14;

  // clang-format off
  static_assert(character_class_table[static_cast<std::uint8_t>(u8'!')] == state::bang);
  static_assert(character_class_table[static_cast<std::uint8_t>(u8'%')] == state::percent);
  static_assert(character_class_table[static_cast<std::uint8_t>(u8'&')] == state::ampersand);
  static_assert(character_class_table[static_cast<std::uint8_t>(u8'+')] == state::plus);
  static_assert(character_class_table[static_cast<std::uint8_t>(u8'=')] == state::equal);
  static_assert(character_class_table[static_cast<std::uint8_t>(u8'>')] == state::greater);
  static_assert(character_class_table[static_cast<std::uint8_t>(u8'^')] == state::circumflex);
  static_assert(character_class_table[static_cast<std::uint8_t>(u8'|')] == state::pipe);
  // clang-format on

  // Returns true if there are no transitions from this state to any other
  // state.
  static bool is_terminal_state(state s) {
    // See NOTE[lex-table-state-order].
    return s >= done_percent_equal;
  }

  // Returns true if there are no transitions from this state to any other
  // state.
  //
  // Precondition: s is an initial state.
  static bool is_initial_state_terminal(state s) {
    // See NOTE[lex-table-state-order].
    return s >= bang_equal;
  }

  static constexpr state
      transition_table[character_class_count + 1][input_state_count] = {
          // !
          {
              retract,  // !!               (invalid)
              retract,  // %!               (invalid)
              retract,  // &!               (invalid)
              retract,  // +!               (invalid)
              retract,  // =!               (invalid)
              retract,  // >!               (invalid)
              retract,  // ^!               (invalid)
              retract,  // |!               (invalid)
              retract,  // !=!              (invalid)
              retract,  // &&!              (invalid)
              retract,  // ==!              (invalid)
              retract,  // >>!              (invalid)
              retract,  // ||!              (invalid)
              retract,  // >>>!             (invalid)
          },
          // %
          {
              retract,  // !%               (invalid)
              retract,  // %%               (invalid)
              retract,  // &%               (invalid)
              retract,  // +%               (invalid)
              retract,  // =%               (invalid)
              retract,  // >%               (invalid)
              retract,  // ^%               (invalid)
              retract,  // |%               (invalid)
              retract,  // !=%              (invalid)
              retract,  // &&%              (invalid)
              retract,  // ==%              (invalid)
              retract,  // >>%              (invalid)
              retract,  // ||%              (invalid)
              retract,  // >>>%             (invalid)
          },
          // &
          {
              retract,              // !&               (invalid)
              retract,              // %&               (invalid)
              ampersand_ampersand,  // & -> &&
              retract,              // +&               (invalid)
              retract,              // =&               (invalid)
              retract,              // >&               (invalid)
              retract,              // ^&               (invalid)
              retract,              // |&               (invalid)
              retract,              // !=&              (invalid)
              retract,              // &&&              (invalid)
              retract,              // ==&              (invalid)
              retract,              // >>&              (invalid)
              retract,              // ||&              (invalid)
              retract,              // >>>&             (invalid)
          },
          // +
          {
              retract,         // !+               (invalid)
              retract,         // %+               (invalid)
              retract,         // &+               (invalid)
              done_plus_plus,  // + -> ++
              retract,         // =+               (invalid)
              retract,         // >+               (invalid)
              retract,         // ^+               (invalid)
              retract,         // |+               (invalid)
              retract,         // !=+              (invalid)
              retract,         // &&+              (invalid)
              retract,         // ==+              (invalid)
              retract,         // >>+              (invalid)
              retract,         // ||+              (invalid)
              retract,         // >>>+             (invalid)
          },
          // =
          {
              bang_equal,                          // ! -> !=
              done_percent_equal,                  // % -> %=
              done_ampersand_equal,                // & -> &=
              done_plus_equal,                     // + -> +=
              equal_equal,                         // = -> ==
              done_greater_equal,                  // > -> >=
              done_circumflex_equal,               // ^ -> ^=
              done_pipe_equal,                     // | -> |=
              done_bang_equal_equal,               // != -> !==
              done_ampersand_ampersand_equal,      // && -> &&=
              done_equal_equal_equal,              // == -> ===
              done_greater_greater_equal,          // >> -> >>=
              done_pipe_pipe_equal,                // || -> ||=
              done_greater_greater_greater_equal,  // >>> -> >>>=
          },
          // >
          {
              retract,                  // !>               (invalid)
              retract,                  // %>               (invalid)
              retract,                  // &>               (invalid)
              retract,                  // +>               (invalid)
              done_equal_greater,       // = -> =>
              greater_greater,          // > -> >>
              retract,                  // ^>               (invalid)
              retract,                  // |>               (invalid)
              retract,                  // !=>              (invalid)
              retract,                  // &&>              (invalid)
              retract,                  // ==>              (invalid)
              greater_greater_greater,  // >> -> >>>
              retract,                  // ||>              (invalid)
              retract,                  // >>>>             (invalid)
          },
          // ^
          {
              retract,  // !^               (invalid)
              retract,  // %^               (invalid)
              retract,  // &^               (invalid)
              retract,  // +^               (invalid)
              retract,  // =^               (invalid)
              retract,  // >^               (invalid)
              retract,  // ^^               (invalid)
              retract,  // |^               (invalid)
              retract,  // !=^              (invalid)
              retract,  // &&^              (invalid)
              retract,  // ==^              (invalid)
              retract,  // >>^              (invalid)
              retract,  // ||^              (invalid)
              retract,  // >>>^             (invalid)
          },
          // |
          {
              retract,    // !|               (invalid)
              retract,    // %|               (invalid)
              retract,    // &|               (invalid)
              retract,    // +|               (invalid)
              retract,    // =|               (invalid)
              retract,    // >|               (invalid)
              retract,    // ^|               (invalid)
              pipe_pipe,  // | -> ||
              retract,    // !=|              (invalid)
              retract,    // &&|              (invalid)
              retract,    // ==|              (invalid)
              retract,    // >>|              (invalid)
              retract,    // |||              (invalid)
              retract,    // >>>|             (invalid)
          },
          // (other)
          {
              retract,  // !(other)         (invalid)
              retract,  // %(other)         (invalid)
              retract,  // &(other)         (invalid)
              retract,  // +(other)         (invalid)
              retract,  // =(other)         (invalid)
              retract,  // >(other)         (invalid)
              retract,  // ^(other)         (invalid)
              retract,  // |(other)         (invalid)
              retract,  // !=(other)        (invalid)
              retract,  // &&(other)        (invalid)
              retract,  // ==(other)        (invalid)
              retract,  // >>(other)        (invalid)
              retract,  // ||(other)        (invalid)
              retract,  // >>>(other)       (invalid)
          },
  };

  static constexpr token_type invalid_token_type = token_type::identifier;
  // See NOTE[lex-table-token-type].
  static constexpr token_type state_to_token[] = {
      token_type::bang,                           // !
      token_type::percent,                        // %
      token_type::ampersand,                      // &
      token_type::plus,                           // +
      token_type::equal,                          // =
      token_type::greater,                        // >
      token_type::circumflex,                     // ^
      token_type::pipe,                           // |
      token_type::bang_equal,                     // !=
      token_type::ampersand_ampersand,            // &&
      token_type::equal_equal,                    // ==
      token_type::greater_greater,                // >>
      token_type::pipe_pipe,                      // ||
      token_type::greater_greater_greater,        // >>>
      token_type::percent_equal,                  // %=
      token_type::ampersand_equal,                // &=
      token_type::plus_plus,                      // ++
      token_type::plus_equal,                     // +=
      token_type::equal_greater,                  // =>
      token_type::greater_equal,                  // >=
      token_type::circumflex_equal,               // ^=
      token_type::pipe_equal,                     // |=
      token_type::bang_equal_equal,               // !==
      token_type::ampersand_ampersand_equal,      // &&=
      token_type::equal_equal_equal,              // ===
      token_type::greater_greater_equal,          // >>=
      token_type::pipe_pipe_equal,                // ||=
      token_type::greater_greater_greater_equal,  // >>>=
  };

  // NOTE[lex-table-lookup]:
  static bool try_parse_current_token(lexer* l) {
    const char8* input = l->input_;

    lex_tables::state old_state;

    // The first lookup is special. In normal DFA tables, there is on initial
    // state. In our table, there are many initial states. The character class
    // of the first character corresponds to the initial state. Therefore, for
    // the first character, do not use lex_tables::transition_table. See
    // NOTE[lex-table-initial].
    lex_tables::state new_state = static_cast<lex_tables::state>(
        lex_tables::character_class_table[static_cast<std::uint8_t>(*input)]);
    QLJS_ASSERT(new_state != lex_tables::state::retract);
    input += 1;
    if (lex_tables::is_initial_state_terminal(new_state)) {
      goto done_with_state_machine;
    }

    // Unrolling seems to improves performance slightly, at least on Arm
    // (Apple M1).
    // GCC won't unroll even if given a #pragma, so unroll using the C
    // preprocessor.
    for (;;) {
#define ONE_ITERATION                                                          \
  do {                                                                         \
    old_state = new_state;                                                     \
    const lex_tables::state* transitions =                                     \
        lex_tables::transition_table[lex_tables::character_class_table         \
                                         [static_cast<std::uint8_t>(*input)]]; \
    new_state = transitions[new_state];                                        \
    input += 1;                                                                \
    if (lex_tables::is_terminal_state(new_state)) {                            \
      goto done_with_state_machine;                                            \
    }                                                                          \
  } while (false)
      ONE_ITERATION;
      ONE_ITERATION;
      ONE_ITERATION;
#undef ONE_ITERATION
    }
  done_with_state_machine:

    bool retract = new_state == lex_tables::state::retract;
    QLJS_WARNING_PUSH
    // Clang thinks that old_state is uninitialized if we goto
    // done_with_state_machine before assigning to it. However, if we didn't
    // assign to old_state, we also asserted that
    // new_state != lex_tables::state::retract, thus retract is false.
    QLJS_WARNING_IGNORE_CLANG("-Wconditional-uninitialized")
    l->last_token_.type =
        lex_tables::state_to_token[retract ? old_state : new_state];
    QLJS_WARNING_POP
    input -= retract ? 1 : 0;
    l->input_ = input;
    l->last_token_.end = input;
    return true;
  }
};
}

#endif

// quick-lint-js finds bugs in JavaScript programs.
// Copyright (C) 2020  Matthew "strager" Glazar
//
// This file is part of quick-lint-js.
//
// quick-lint-js is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// quick-lint-js is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with quick-lint-js.  If not, see <https://www.gnu.org/licenses/>.
